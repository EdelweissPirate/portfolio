/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
*/

import React, { useMemo, useRef, useState } from 'react'
import { useFrame } from "@react-three/fiber";
import { Line, useGLTF } from '@react-three/drei'
import * as THREE from 'three'

import soundBell from '../assets/sounds/ping.mp3'

function Model(props) {
  const { nodes, materials } = useGLTF('../assets/3d/UFO.gltf')

  const ref = useRef()
  const line = useRef()
  const chassis = useRef()
  const lights = useRef()
  
  const [modelPos, setModelPos] = useState([...props.position])
  const [cooldown, setCooldown] = useState(Math.random() * 100)
  const [clicked, setClicked] = useState(false)
  
  const ping = useMemo(() => new Audio(soundBell), [soundBell])

  const handleClick = () => {
    ping.volume = .5
    ping.play()
    setClicked(true)
  }

  useFrame(({ clock }) => {
      const r = props.radius

      if(!clicked){
        if(props.direction === 'clockwise'){
          chassis.current.rotation.y += 0.3
          lights.current.rotation.y += 0.3
          ref.current.position.x = (r * Math.cos(clock.getElapsedTime() * (1 + props.speed)))
          ref.current.position.z = (r * Math.sin(clock.getElapsedTime() * (1 + props.speed)))
        } else {
          chassis.current.rotation.y -= 0.3
          lights.current.rotation.y -= 0.3
          ref.current.position.x = (r * Math.sin(clock.getElapsedTime() * (1 + props.speed)))
          ref.current.position.z = (r * Math.cos(clock.getElapsedTime() * (1 + props.speed)))
        }
  
        ref.current.position.y = (props.position[1] + 3 * Math.sin(clock.getElapsedTime() / 2))
  
        function randNum() {
          return Math.random() * 2
        }
  
        if(props.attackTarget && cooldown >= (80 + (randNum() * 10))){
        // if(props.attackTarget && cooldown >= 80){
          const targetPos = ref.current.worldToLocal(
            new THREE.Vector3(
              props.attackTarget.position.x,// + randNum(), 
              (props.attackTarget.position.y + 4),// + randNum(), 
              props.attackTarget.position.z// + randNum()
            )
          )
  
          setModelPos([targetPos.x, targetPos.y, targetPos.z])
        } else {
          setModelPos([0, 0, 0])
        }
  
        if(cooldown >= 0){
          setCooldown(cooldown - 0.5)
        } else {
          setCooldown(100)
        }
      } else {
        chassis.current.rotation.y += 0.6
        lights.current.rotation.y += 0.6
        ref.current.position.x -= 1 //(r * Math.cos(clock.getElapsedTime() * (1 + props.speed)))
        ref.current.position.z -= 1
      }
      
  }, []);

  return (
    <>
      <group {...props} ref={ref} dispose={null} onClick={handleClick}>
        <mesh ref={chassis} geometry={nodes.Sphere_1.geometry} material={materials.Metal} />
        <mesh ref={lights} geometry={nodes.Sphere_2.geometry} material={materials.Light} />
        <mesh geometry={nodes.Sphere_3.geometry} material={materials['Material.001']} />

        <Line 
        ref={line}
        points={[[0, 0, 0], [...modelPos]]}
        color="red"
        lineWidth={2}
        dashed={false}
        /> 

      </group>
    </>
  )
}

useGLTF.preload('../assets/3d/UFO.gltf')

export default Model
